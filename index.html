//+------------------------------------------------------------------+
//| ForexFibonacci Candle Volatility Projector (FCVP) and FearWave by SPXMASTERY |
//| Copyright 2025, Russell Clark SPXMASTERY.com |
//| https://www.mql5.com |
//| Build 1 Version 57 - Greatest EA: CPU optimized (bar-based, shortened periods, caching); slippage logging for demo/live.
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, Russell Clark SPXMASTERY.com"
#property link "https://www.mql5.com"
#property version "1.57"
#property description "Forex Fear Wave EA integrated with Fibonacci Candle Volatility Projector (FCVP) for any timeframe scalping. Adjustable time offset. Integrated VWAP for self-contained bias calculation. Greatest EA: CPU optimized (bar-based, shortened periods, caching); slippage logging for demo/live."
#include <Trade\Trade.mqh>
// Integrated VWAP Enums
enum FCVP_VWAP_DATE_TYPE
  {
   FCVP_VWAP_DAILY,
   FCVP_VWAP_WEEKLY,
   FCVP_VWAP_MONTHLY
  };
enum FCVP_PRICE_TYPE
  {
   FCVP_OPEN,
   FCVP_CLOSE,
   FCVP_HIGH,
   FCVP_LOW,
   FCVP_OPEN_CLOSE,
   FCVP_HIGH_LOW,
   FCVP_CLOSE_HIGH_LOW,
   FCVP_OPEN_CLOSE_HIGH_LOW
  };
// Inputs
input double FCVP_LotSize = 0.01;
input double FCVP_FearThreshold = 500.0;
input double FCVP_ForesightThreshold = 0.3;
input int FCVP_SessionStartHour = 8;
input int FCVP_SessionEndHour = 9;
input int FCVP_TimeOffset = -6;
input bool FCVP_UseBrokerCST = false;
input int FCVP_LookbackDays = 100;
input double FCVP_VegaThreshold = 1.3; // Tightened
input ENUM_TIMEFRAMES FCVP_LowerTF = PERIOD_M5;
input ENUM_TIMEFRAMES FCVP_HigherTF = PERIOD_H1;
input bool FCVP_UseZoneCheck = false;
input double FCVP_Buffer = 0.0001;
input bool FCVP_IgnorePauses = true;
input bool FCVP_DebugMode = true;
input double FCVP_RiskPercent = 1.0;
input double FCVP_SLMulti = 4.0; // Widened for longer SL
input double FCVP_TPMulti = 0.2; // Smaller for higher wins
input int FCVP_BreakevenPips = 20;
input bool FCVP_UseVirtualSL = true;
input string FCVP_TrailingType = "Chandelier"; // New option for runners
input double FCVP_PartialClosePct = 50.0;
input double FCVP_TrailStep = 20.0; // Widened from 10
input int FCVP_MaxOpen = 3;
input int FCVP_CooldownSecs = 1;
input int FCVP_MaxTradesDay = 10000; // "Off" for data
input double FCVP_HurstThreshold = 0.45; // Loosened from 0.5
input int FCVP_HurstPeriod = 50; // Shortened from 100
input int FCVP_MaxPyramids = 2;
input int FCVP_GARCHPeriod = 10; // Shortened from 20
input string FCVP_VWAP_Name = "Integrated Volume Weighted Average Price (VWAP)";
input FCVP_PRICE_TYPE FCVP_VWAP_Price_Type = FCVP_CLOSE_HIGH_LOW;
input bool FCVP_VWAP_Enable_Daily = true;
input bool FCVP_VWAP_Enable_Weekly = false;
input bool FCVP_VWAP_Enable_Monthly = false;
input bool FCVP_ForceTrading = true;
input bool FCVP_EnableAlerts = false;
input bool FCVP_RestrictHyperToSession = false;
input bool FCVP_TestMode = true;
input int FCVP_FixedSLPips = 35; // New: Fixed SL in pips for losses
input int FCVP_FixedTPPips = 0; // New: 0 for no TP, use trail for wins
input double FCVP_ChandelierMulti = 4.0; // Widened from 3.0 for ~100 pips room
input int FCVP_TrailAfterPips = 35; // Start trail after this profit
input double FCVP_GARCHPauseThreshold = 0.01; // Tightened for pauses
input int FCVP_PyramidMinPips = 5; // Lower threshold for pyramid
input string FCVP_Symbols = "EURUSD,GBPUSD"; // Multi-pair ready (future: loop over StringSplit)
// Globals (added for Chandelier)
double FCVP_FHVV = 0.0;
double FCVP_Vega = 1.0;
double FCVP_Bias = 0.0;
double FCVP_Hurst = 0.5;
double FCVP_GARCH_Vol = 0.0;
double FCVP_Prev_GARCH = 0.0;
double FCVP_ACH = 0.0;
double FCVP_ACL = 0.0;
MqlRates FCVP_rates[];
int FCVP_rsi_handle = INVALID_HANDLE;
int FCVP_macd_handle = INVALID_HANDLE;
int FCVP_sma_handle = INVALID_HANDLE;
int FCVP_ema_handle = INVALID_HANDLE;
int FCVP_atr_handle = INVALID_HANDLE;
int FCVP_psar_handle = INVALID_HANDLE;
int FCVP_wins = 0;
int FCVP_losses = 0;
datetime FCVP_last_halt_print = 0;
datetime FCVP_last_entry_debug = 0;
datetime FCVP_last_condition_debug = 0;
datetime FCVP_last_trade_time = 0;
int FCVP_daily_trades = 0;
datetime FCVP_current_day = 0;
int FCVP_bars_per_session = 0;
const int FCVP_MIN_BARS_REQUIRED = 200;
const int FCVP_MIN_LOOKBACK_DAYS = 100;
long FCVP_stop_level = 0;
double FCVP_pip_value = 0.0;
long FCVP_next_magic = 123456789;
datetime FCVP_last_dd_alert = 0;
datetime FCVP_last_fhvv_debug = 0;
datetime FCVP_last_vwap_time = 0;
datetime FCVP_last_news_time = 0;
datetime FCVP_last_bar_time = 0;
double FCVP_cached_slope = 0.0;
datetime FCVP_last_slope_time = 0;
int FCVP_slippage_log_handle = INVALID_HANDLE; // Renamed from file_handle
// VWAP Globals
double FCVP_VWAP_Buffer_Daily[];
double FCVP_VWAP_Buffer_Weekly[];
double FCVP_VWAP_Buffer_Monthly[];
double FCVP_VWAP_PriceArr[];
double FCVP_VWAP_TotalTPV[];
double FCVP_VWAP_TotalVol[];
double FCVP_VWAP_SumDailyTPV = 0, FCVP_VWAP_SumWeeklyTPV = 0, FCVP_VWAP_SumMonthlyTPV = 0;
double FCVP_VWAP_SumDailyVol = 0, FCVP_VWAP_SumWeeklyVol = 0, FCVP_VWAP_SumMonthlyVol = 0;
int FCVP_VWAP_IdxDaily=0, FCVP_VWAP_IdxWeekly=0, FCVP_VWAP_IdxMonthly=0, FCVP_VWAP_Idx=0;
bool FCVP_VWAP_IsFirstRun=true;
ENUM_TIMEFRAMES FCVP_VWAP_LastTimePeriod=PERIOD_MN1;
datetime FCVP_VWAP_LastDay;
datetime FCVP_VWAP_LastWeek;
datetime FCVP_VWAP_LastMonth;
double FCVP_VWAP_Current = 0.0;
// Function prototypes
double CalculateFHVV(ENUM_TIMEFRAMES tf);
double CalculateVega();
double CalculateBiasEnsemble();
double LinearRegressionSlope();
double CalculateHurst();
double CalculateGARCHProxy();
double CalculateForesightScore();
void CalculateDualBands();
void DrawBands();
void DrawEntryArrow(bool isBuy);
double CalculateFearScore();
double GetATR();
double ScaledLotSize(double sl_distance);
void UpdateTrailingStops();
bool IsTradingTime();
bool IsHighVolPause();
double ArrayAvg(double &arr[]);
double StdDev(double &arr[]);
void UpdateWinLoss();
void EnterTrade(bool buy);
bool HasHighImpactNews();
double GetSwingHigh(int bars);
double GetSwingLow(int bars);
double GetPSAR();
void PyramidOnWinner(ulong ticket);
double CalculateDrawdown();
void CloseAllPositions();
bool IsPastSessionEnd15Min();
datetime FCVP_VWAP_CreateDateTime(FCVP_VWAP_DATE_TYPE nReturnType=FCVP_VWAP_DATE_TYPE::FCVP_VWAP_DAILY, datetime dtDay=D'2000.01.01 00:00:00', int pHour=0, int pMinute=0, int pSecond=0);
void FCVP_VWAP_Compute();
double PredictBias(double &features[]);
// OnInit
int OnInit() {
  int FCVP_period_minutes = (int)(PeriodSeconds(_Period) / 60);
  FCVP_bars_per_session = 240 / FCVP_period_minutes;
  FCVP_rsi_handle = iRSI(_Symbol, _Period, 14, PRICE_CLOSE);
  if (FCVP_rsi_handle == INVALID_HANDLE) { Print("Failed to create RSI handle"); return INIT_FAILED; }
  FCVP_macd_handle = iMACD(_Symbol, _Period, 12, 26, 9, PRICE_CLOSE);
  if (FCVP_macd_handle == INVALID_HANDLE) { Print("Failed to create MACD handle"); return INIT_FAILED; }
  FCVP_ema_handle = iMA(_Symbol, _Period, 20, 0, MODE_EMA, PRICE_CLOSE);
  if (FCVP_ema_handle == INVALID_HANDLE) { Print("Failed to create EMA handle"); return INIT_FAILED; }
  FCVP_atr_handle = iATR(_Symbol, _Period, 14);
  if (FCVP_atr_handle == INVALID_HANDLE) { Print("Failed to create ATR handle"); return INIT_FAILED; }
  FCVP_sma_handle = iMA(_Symbol, _Period, 50, 0, MODE_SMA, PRICE_CLOSE);
  if (FCVP_sma_handle == INVALID_HANDLE) { Print("Failed to create SMA handle"); return INIT_FAILED; }
  FCVP_psar_handle = iSAR(_Symbol, _Period, 0.02, 0.2);
  if (FCVP_psar_handle == INVALID_HANDLE) { Print("Failed to create PSAR handle"); return INIT_FAILED; }
  FCVP_stop_level = SymbolInfoInteger(_Symbol, SYMBOL_TRADE_STOPS_LEVEL);
  FCVP_pip_value = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE_LOSS) / SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
  ArraySetAsSeries(FCVP_rates, true);
  UpdateWinLoss();
  datetime FCVP_init_day = TimeCurrent() - (TimeCurrent() % 86400); // Local, no hide
  FCVP_current_day = FCVP_init_day; // Assign to global
  FCVP_last_vwap_time = iTime(_Symbol, _Period, 0);
  FCVP_last_bar_time = iTime(_Symbol, _Period, 0);
  Print("Timeframe: ", EnumToString(_Period), " Bars per session: ", FCVP_bars_per_session);
  // Integrated VWAP init
  FCVP_VWAP_LastDay = FCVP_VWAP_CreateDateTime(FCVP_VWAP_DATE_TYPE::FCVP_VWAP_DAILY);
  FCVP_VWAP_LastWeek = FCVP_VWAP_CreateDateTime(FCVP_VWAP_DATE_TYPE::FCVP_VWAP_WEEKLY);
  FCVP_VWAP_LastMonth = FCVP_VWAP_CreateDateTime(FCVP_VWAP_DATE_TYPE::FCVP_VWAP_MONTHLY);
  ArraySetAsSeries(FCVP_VWAP_Buffer_Daily, true);
  ArraySetAsSeries(FCVP_VWAP_Buffer_Weekly, true);
  ArraySetAsSeries(FCVP_VWAP_Buffer_Monthly, true);
  FCVP_slippage_log_handle = FileOpen("slippage.log", FILE_WRITE|FILE_TXT|FILE_ANSI|FILE_SHARE_READ);
  if (FCVP_slippage_log_handle == INVALID_HANDLE) Print("Slippage log file open failed");
  return INIT_SUCCEEDED;
}
// OnDeinit
void OnDeinit(const int reason) {
  IndicatorRelease(FCVP_rsi_handle);
  IndicatorRelease(FCVP_macd_handle);
  IndicatorRelease(FCVP_ema_handle);
  IndicatorRelease(FCVP_atr_handle);
  IndicatorRelease(FCVP_sma_handle);
  IndicatorRelease(FCVP_psar_handle);
  ObjectsDeleteAll(0, -1, -1);
  if (FCVP_slippage_log_handle != INVALID_HANDLE) FileClose(FCVP_slippage_log_handle);
}
// OnTick
void OnTick() {
  int FCVP_copied = CopyRates(_Symbol, _Period, 0, FCVP_LookbackDays * FCVP_bars_per_session + 100, FCVP_rates);
  if (FCVP_copied < FCVP_MIN_BARS_REQUIRED) {
    Print("Insufficient bars for full computation: ", FCVP_copied, " < ", FCVP_MIN_BARS_REQUIRED);
    return;
  }
  datetime current_bar_time = iTime(_Symbol, _Period, 0);
  if (current_bar_time != FCVP_last_bar_time) {
    double FCVP_FHVV_current = CalculateFHVV(_Period);
    double FCVP_FHVV_lower = CalculateFHVV(FCVP_LowerTF);
    double FCVP_FHVV_higher = CalculateFHVV(FCVP_HigherTF);
    static double FCVP_ema_fhvv = 0.0;
    double FCVP_raw_fhvv = 0.5 * FCVP_FHVV_current + 0.3 * FCVP_FHVV_lower + 0.2 * FCVP_FHVV_higher;
    if (FCVP_ema_fhvv == 0.0) FCVP_ema_fhvv = FCVP_raw_fhvv;
    FCVP_ema_fhvv = FCVP_ema_fhvv * 0.9 + FCVP_raw_fhvv * 0.1;
    FCVP_FHVV = FCVP_ema_fhvv;
    if (FCVP_FHVV <= 0.0) {
      FCVP_FHVV = GetATR() * 1.5; // Enhanced fallback
      if (FCVP_DebugMode) Print("Data skip: FHVV fallback to ATR*1.5 = ", FCVP_FHVV);
    }
    FCVP_Hurst = CalculateHurst();
    FCVP_Prev_GARCH = FCVP_GARCH_Vol;
    FCVP_GARCH_Vol = CalculateGARCHProxy();
    if (FCVP_GARCH_Vol <= 0.0) FCVP_GARCH_Vol = 0.0001;
    if (TimeCurrent() - FCVP_last_slope_time > 5) {
      FCVP_cached_slope = LinearRegressionSlope();
      FCVP_last_slope_time = TimeCurrent();
    }
    FCVP_Bias = CalculateBiasEnsemble();
    FCVP_last_bar_time = current_bar_time;
  }
  if (iTime(_Symbol, _Period, 0) != FCVP_last_vwap_time) {
    FCVP_VWAP_Compute();
    FCVP_last_vwap_time = iTime(_Symbol, _Period, 0);
  }
  FCVP_Vega = CalculateVega();
  double FCVP_foresight = CalculateForesightScore();
  CalculateDualBands();
  DrawBands();
  double FCVP_fear = CalculateFearScore();
  bool FCVP_trading_time = FCVP_ForceTrading ? true : IsTradingTime(); // Full override
  bool FCVP_high_vol_pause = IsHighVolPause() || (FCVP_GARCH_Vol > FCVP_Prev_GARCH * 1.5);
  bool FCVP_news_pause = HasHighImpactNews();
  if (FCVP_news_pause) FCVP_last_news_time = TimeCurrent();
  bool FCVP_news_duration_pause = (TimeCurrent() - FCVP_last_news_time < 1800);
  bool is_tester = MQLInfoInteger(MQL_TESTER);
  bool ignore_pauses = FCVP_IgnorePauses || (is_tester && FCVP_TestMode);
  if (FCVP_high_vol_pause || FCVP_news_pause || FCVP_news_duration_pause) {
    Print("Anomaly: High vol or news - intervention needed");
  }
  if (FCVP_DebugMode && TimeCurrent() - FCVP_last_condition_debug > 300) {
    Print("Entry conditions: Bias=", FCVP_Bias, ", Foresight=", FCVP_foresight, ", Hurst=", FCVP_Hurst, ", Fear=", FCVP_fear, ", InZone=", FCVP_UseZoneCheck ? (FCVP_rates[0].close >= FCVP_ACL && FCVP_rates[0].close <= FCVP_ACH) : true,
          ", TradingTime=", FCVP_trading_time, ", HighVolPause=", FCVP_high_vol_pause, ", NewsPause=", FCVP_news_pause);
    FCVP_last_condition_debug = TimeCurrent();
  }
  if (IsPastSessionEnd15Min() && PositionsTotal() > 0) {
    CloseAllPositions();
    Print("Post-session force close at 9:15 CST");
  }
  if ((!FCVP_trading_time || FCVP_high_vol_pause || FCVP_news_pause || FCVP_news_duration_pause) && !ignore_pauses) {
    if (TimeCurrent() - FCVP_last_halt_print > 3600) {
      Print("Trading halted due to time/vol/news");
      FCVP_last_halt_print = TimeCurrent();
    }
    UpdateTrailingStops();
    return;
  }
  bool FCVP_in_zone = true;
  if (FCVP_UseZoneCheck) FCVP_in_zone = (FCVP_rates[0].close >= FCVP_ACL && FCVP_rates[0].close <= FCVP_ACH);
  datetime FCVP_day = TimeCurrent() - (TimeCurrent() % 86400);
  if (FCVP_day != FCVP_current_day) {
    FCVP_daily_trades = 0;
    FCVP_current_day = FCVP_day;
  }
  if (MathAbs(FCVP_Bias) > 0.0 && FCVP_foresight > FCVP_ForesightThreshold && FCVP_Hurst > FCVP_HurstThreshold && FCVP_in_zone && FCVP_fear < FCVP_FearThreshold &&
      PositionsTotal() < FCVP_MaxOpen && TimeCurrent() - FCVP_last_trade_time > FCVP_CooldownSecs && FCVP_daily_trades < FCVP_MaxTradesDay) {
    if (FCVP_Bias > 0) {
      EnterTrade(true);
    } else if (FCVP_Bias < 0) {
      EnterTrade(false);
    }
    FCVP_last_trade_time = TimeCurrent();
    FCVP_daily_trades++;
  }
  UpdateTrailingStops();
  double FCVP_dd = CalculateDrawdown();
  if (FCVP_dd > 1.0 && TimeCurrent() - FCVP_last_dd_alert > 300) {
    Print("Drawdown >1%: " + DoubleToString(FCVP_dd, 2) + " - Monitor positions");
    FCVP_last_dd_alert = TimeCurrent();
  }
  if (FCVP_dd > 2.0) {
    CloseAllPositions();
    Print("Critical DD >2% - All positions closed");
  }
}
// OnTradeTransaction
void OnTradeTransaction(const MqlTradeTransaction &trans, const MqlTradeRequest &request, const MqlTradeResult &result) {
  if (trans.type == TRADE_TRANSACTION_DEAL_ADD) {
    if (HistoryDealGetInteger(trans.deal, DEAL_ENTRY) == DEAL_ENTRY_OUT) {
      UpdateWinLoss();
    }
    if (HistoryDealGetInteger(trans.deal, DEAL_ENTRY) == DEAL_ENTRY_IN) {
      long deal_type = HistoryDealGetInteger(trans.deal, DEAL_TYPE);
      double deal_price = HistoryDealGetDouble(trans.deal, DEAL_PRICE);
      double current_ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
      double current_bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
      double slippage = 0;
      if (deal_type == DEAL_TYPE_BUY) slippage = (deal_price - current_ask) / _Point;
      else if (deal_type == DEAL_TYPE_SELL) slippage = (current_bid - deal_price) / _Point;
      if (FCVP_slippage_log_handle != INVALID_HANDLE) FileWrite(FCVP_slippage_log_handle, TimeToString(TimeCurrent(), TIME_DATE|TIME_SECONDS) + " Slippage: " + DoubleToString(slippage, 2) + " pips");
    }
  }
}
// CalculateFHVV
double CalculateFHVV(ENUM_TIMEFRAMES tf) {
  datetime FCVP_earliest;
  if (!SeriesInfoInteger(_Symbol, tf, SERIES_FIRSTDATE, FCVP_earliest)) {
    Print("SeriesInfoInteger failed for TF ", EnumToString(tf));
    return 0.0;
  }
  long FCVP_available_secs = TimeCurrent() - FCVP_earliest;
  int FCVP_available_days = (int)(FCVP_available_secs / 86400);
  int FCVP_effective_lookback = MathMin(FCVP_LookbackDays, FCVP_available_days);
  if (FCVP_effective_lookback < FCVP_MIN_LOOKBACK_DAYS) {
    if (FCVP_DebugMode) Print("Warning: Available days ", FCVP_available_days, " < min for TF ", EnumToString(tf));
    return 0.0; // Trigger fallback
  } else if (FCVP_effective_lookback < FCVP_LookbackDays && FCVP_DebugMode) {
    Print("Adjusted lookback to ", FCVP_effective_lookback, " days for TF ", EnumToString(tf));
  }
  datetime FCVP_start_time = (datetime)(TimeCurrent() - (long)FCVP_effective_lookback * 86400LL);
  MqlRates FCVP_tf_rates[];
  int FCVP_copied_tf = CopyRates(_Symbol, tf, FCVP_start_time, TimeCurrent(), FCVP_tf_rates);
  if (FCVP_copied_tf <= 0) {
    Print("CopyRates failed for TF ", EnumToString(tf));
    return 0.0;
  }
  ArraySetAsSeries(FCVP_tf_rates, true);
  double FCVP_acr_sum = 0.0;
  int FCVP_day_count = 0;
  datetime FCVP_loop_day = 0;
  double FCVP_daily_sum = 0.0;
  int FCVP_daily_count = 0;
  for (int i = ArraySize(FCVP_tf_rates) - 1; i >= 0; i--) {
    datetime FCVP_time = FCVP_tf_rates[i].time;
    MqlDateTime FCVP_dt;
    TimeToStruct(FCVP_time, FCVP_dt);
    datetime FCVP_day = FCVP_time - (FCVP_time % 86400);
    if (FCVP_day != FCVP_loop_day) {
      if (FCVP_daily_count > 0) {
        FCVP_acr_sum += FCVP_daily_sum / FCVP_daily_count;
        FCVP_day_count++;
      }
      FCVP_loop_day = FCVP_day;
      FCVP_daily_sum = 0.0;
      FCVP_daily_count = 0;
    }
    int FCVP_hour = FCVP_dt.hour + (FCVP_UseBrokerCST ? 0 : FCVP_TimeOffset);
    if (FCVP_hour < 0) FCVP_hour += 24;
    if (FCVP_hour >= 24) FCVP_hour -= 24;
    if (FCVP_hour >= FCVP_SessionStartHour && FCVP_hour < FCVP_SessionEndHour) {
      FCVP_daily_sum += FCVP_tf_rates[i].high - FCVP_tf_rates[i].low;
      FCVP_daily_count++;
    }
  }
  if (FCVP_daily_count > 0) {
    FCVP_acr_sum += FCVP_daily_sum / FCVP_daily_count;
    FCVP_day_count++;
  }
  return (FCVP_day_count > 0) ? FCVP_acr_sum / FCVP_day_count : 0.0;
}
// CalculateVega
double CalculateVega() {
  long FCVP_current_vol = FCVP_rates[0].tick_volume;
  long FCVP_avg_vol = 0;
  for (int i = 1; i <= 20; i++) {
    if (i >= ArraySize(FCVP_rates)) break;
    FCVP_avg_vol += FCVP_rates[i].tick_volume;
  }
  FCVP_avg_vol /= 20;
  double FCVP_ratio = (FCVP_avg_vol > 0) ? (double)FCVP_current_vol / FCVP_avg_vol : 1.0;
  if (FCVP_ratio > FCVP_VegaThreshold) FCVP_ratio *= 1.2;
  static double FCVP_ema_vega = 1.0;
  FCVP_ema_vega = FCVP_ema_vega * 0.9 + FCVP_ratio * 0.1;
  return FCVP_ema_vega;
}
// CalculateBiasEnsemble
double CalculateBiasEnsemble() {
  double FCVP_rsi[1], FCVP_macd[1], FCVP_ema[1];
  if (CopyBuffer(FCVP_rsi_handle, 0, 0, 1, FCVP_rsi) <= 0 ||
      CopyBuffer(FCVP_macd_handle, 0, 0, 1, FCVP_macd) <= 0 ||
      CopyBuffer(FCVP_ema_handle, 0, 0, 1, FCVP_ema) <= 0) return 0.0;
  double FCVP_close = FCVP_rates[0].close;
  if (TimeCurrent() - FCVP_last_slope_time > 5) {
    FCVP_cached_slope = LinearRegressionSlope();
    FCVP_last_slope_time = TimeCurrent();
  }
  double features[];
  ArrayResize(features, 5);
  features[0] = (FCVP_rsi[0] > 50) ? 1.0 : 0.0;
  features[1] = (FCVP_macd[0] > 0) ? 1.0 : 0.0;
  features[2] = (FCVP_close > FCVP_ema[0]) ? 1.0 : 0.0;
  features[3] = (FCVP_close > FCVP_VWAP_Current) ? 1.0 : 0.0;
  features[4] = (FCVP_cached_slope > 0) ? 1.0 : 0.0;
  double ml_bias = PredictBias(features);
  return (ml_bias * 2.0 - 1.0); // Scale to -1 to 1
}
// PredictBias (ML weights from torch)
double PredictBias(double &features[]) {
  if (ArraySize(features) != 5) return 0.5;
  double sum = 0.0;
  sum += features[0] * 0.248463;
  sum += features[1] * 0.271533;
  sum += features[2] * 0.269685;
  sum += features[3] * 0.286978;
  sum += features[4] * 0.294114;
  sum += -0.466735;
  return 1.0 / (1.0 + MathExp(-sum)); // Sigmoid
}
// LinearRegressionSlope
double LinearRegressionSlope() {
  int FCVP_period = 14;
  if (ArraySize(FCVP_rates) < FCVP_period) return 0.0;
  double FCVP_x_sum = 0.0, FCVP_y_sum = 0.0, FCVP_xy_sum = 0.0, FCVP_x2_sum = 0.0;
  for (int i = 0; i < FCVP_period; i++) {
    double FCVP_x = (double)i;
    double FCVP_y = FCVP_rates[i].close;
    FCVP_x_sum += FCVP_x;
    FCVP_y_sum += FCVP_y;
    FCVP_xy_sum += FCVP_x * FCVP_y;
    FCVP_x2_sum += FCVP_x * FCVP_x;
  }
  double FCVP_n = (double)FCVP_period;
  return (FCVP_n * FCVP_xy_sum - FCVP_x_sum * FCVP_y_sum) / (FCVP_n * FCVP_x2_sum - FCVP_x_sum * FCVP_x_sum);
}
// CalculateHurst
double CalculateHurst() {
  int FCVP_period = FCVP_HurstPeriod;
  if (ArraySize(FCVP_rates) < FCVP_period + 1) return 0.5;
  double FCVP_logs[];
  ArrayResize(FCVP_logs, FCVP_period);
  for (int i = 0; i < FCVP_period; i++) {
    if (FCVP_rates[i + 1].close <= 0.0) return 0.5;
    FCVP_logs[i] = MathLog(FCVP_rates[i].close / FCVP_rates[i + 1].close);
  }
  double FCVP_mean = ArrayAvg(FCVP_logs);
  double FCVP_cum[];
  ArrayResize(FCVP_cum, FCVP_period);
  FCVP_cum[0] = FCVP_logs[0] - FCVP_mean;
  for (int i = 1; i < FCVP_period; i++) {
    FCVP_cum[i] = FCVP_cum[i - 1] + FCVP_logs[i] - FCVP_mean;
  }
  int FCVP_max_idx = ArrayMaximum(FCVP_cum);
  int FCVP_min_idx = ArrayMinimum(FCVP_cum);
  double FCVP_R = FCVP_cum[FCVP_max_idx] - FCVP_cum[FCVP_min_idx];
  double FCVP_S = StdDev(FCVP_logs);
  if (FCVP_S <= 0.0) return 0.5;
  double FCVP_RS = FCVP_R / FCVP_S;
  if (FCVP_RS <= 0.0) return 0.5;
  return MathLog(FCVP_RS) / MathLog((double)FCVP_period / 2.0);
  // Future: Offload to DLL for multi-core
}
// CalculateGARCHProxy
double CalculateGARCHProxy() {
  int FCVP_period = FCVP_GARCHPeriod;
  if (ArraySize(FCVP_rates) < FCVP_period + 1) return 0.0001;
  double FCVP_lambda = 0.94;
  double FCVP_ewma = 0.0;
  for (int i = FCVP_period - 1; i >= 0; i--) {
    if (FCVP_rates[i + 1].close <= 0.0) continue;
    double FCVP_ret = (FCVP_rates[i].close - FCVP_rates[i + 1].close) / FCVP_rates[i + 1].close;
    double FCVP_sq = FCVP_ret * FCVP_ret;
    FCVP_ewma = FCVP_lambda * FCVP_ewma + (1 - FCVP_lambda) * FCVP_sq;
  }
  if (FCVP_ewma <= 0.0) FCVP_ewma = 0.0001;
  return MathSqrt(FCVP_ewma);
  // Future: Offload to DLL for multi-core
}
// CalculateForesightScore
double CalculateForesightScore() {
  return 0.5 * FCVP_Hurst + 0.3 * (1.0 - FCVP_GARCH_Vol) + 0.2 * MathAbs(FCVP_Bias);
}
// CalculateDualBands
void CalculateDualBands() {
  double FCVP_close = FCVP_rates[0].close;
  double FCVP_proj = FCVP_FHVV * FCVP_Vega * 3.0;
  FCVP_ACH = FCVP_close + FCVP_proj + FCVP_Buffer;
  FCVP_ACL = FCVP_close - FCVP_proj - FCVP_Buffer;
}
// DrawBands
void DrawBands() {
  string FCVP_ach_name = "ACH_Line";
  ObjectCreate(ChartID(), FCVP_ach_name, OBJ_TREND, 0, FCVP_rates[0].time, FCVP_ACH, FCVP_rates[1].time, FCVP_ACH);
  ObjectSetInteger(ChartID(), FCVP_ach_name, OBJPROP_COLOR, clrGreen);
  ObjectSetInteger(ChartID(), FCVP_ach_name, OBJPROP_WIDTH, 2);
  string FCVP_acl_name = "ACL_Line";
  ObjectCreate(ChartID(), FCVP_acl_name, OBJ_TREND, 0, FCVP_rates[0].time, FCVP_ACL, FCVP_rates[1].time, FCVP_ACL);
  ObjectSetInteger(ChartID(), FCVP_acl_name, OBJPROP_COLOR, clrRed);
  ObjectSetInteger(ChartID(), FCVP_acl_name, OBJPROP_WIDTH, 2);
  string FCVP_fhvv_label = "FHVV_Label";
  ObjectCreate(ChartID(), FCVP_fhvv_label, OBJ_LABEL, 0, 0, 0);
  ObjectSetString(ChartID(), FCVP_fhvv_label, OBJPROP_TEXT, "FHVV: " + DoubleToString(FCVP_FHVV, 5));
  ObjectSetInteger(ChartID(), FCVP_fhvv_label, OBJPROP_CORNER, CORNER_LEFT_UPPER);
  ObjectSetInteger(ChartID(), FCVP_fhvv_label, OBJPROP_XDISTANCE, 10);
  ObjectSetInteger(ChartID(), FCVP_fhvv_label, OBJPROP_YDISTANCE, 10);
}
// DrawEntryArrow
void DrawEntryArrow(bool isBuy) {
  string FCVP_name = "EntryArrow_" + IntegerToString(TimeCurrent());
  int FCVP_code = isBuy ? 233 : 234;
  ObjectCreate(ChartID(), FCVP_name, OBJ_ARROW, 0, FCVP_rates[0].time, FCVP_rates[0].close);
  ObjectSetInteger(ChartID(), FCVP_name, OBJPROP_ARROWCODE, FCVP_code);
  ObjectSetInteger(ChartID(), FCVP_name, OBJPROP_COLOR, isBuy ? clrBlue : clrRed);
}
// CalculateFearScore
double CalculateFearScore() {
  double FCVP_atr = GetATR();
  double FCVP_vol_anomaly = (FCVP_Vega > 1.3) ? FCVP_Vega : 1.0;
  double FCVP_hv = FCVP_FHVV;
  double FCVP_iv = FCVP_GARCH_Vol;
  double FCVP_fear = 0.4 * FCVP_atr + 0.3 * FCVP_vol_anomaly + 0.2 * FCVP_hv + 0.1 * FCVP_iv;
  return (FCVP_fear > FCVP_FearThreshold) ? FCVP_FearThreshold : FCVP_fear;
}
// GetATR
double GetATR() {
  double FCVP_atr[1];
  if (CopyBuffer(FCVP_atr_handle, 0, 0, 1, FCVP_atr) <= 0) return FCVP_FHVV;
  return FCVP_atr[0];
}
// ScaledLotSize
double ScaledLotSize(double sl_distance) {
  double FCVP_balance = AccountInfoDouble(ACCOUNT_BALANCE);
  double FCVP_risk_amount = FCVP_balance * (FCVP_RiskPercent / 100.0);
  double FCVP_base_lot = NormalizeDouble(FCVP_risk_amount / (sl_distance / _Point * FCVP_pip_value), 2);
  double FCVP_win_rate = (FCVP_wins + FCVP_losses > 0) ? (double)FCVP_wins / (FCVP_wins + FCVP_losses) : 0.5;
  double FCVP_lot = FCVP_base_lot * (0.5 + FCVP_win_rate);
  return MathMax(FCVP_lot, SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN));
}
// UpdateTrailingStops
void UpdateTrailingStops() {
  CTrade FCVP_trade;
  double FCVP_bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
  double FCVP_ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
  double FCVP_min_distance = FCVP_stop_level * _Point + _Point;
  double FCVP_atr = GetATR();
  double FCVP_breakeven = FCVP_BreakevenPips * _Point;
  double FCVP_trail_step = FCVP_TrailStep * _Point;
  for (int i = PositionsTotal() - 1; i >= 0; i--) {
    ulong FCVP_ticket = PositionGetTicket(i);
    if (FCVP_ticket == 0) continue;
    if (PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
    datetime FCVP_open_time = (datetime)PositionGetInteger(POSITION_TIME);
    if (TimeCurrent() - FCVP_open_time < 30) continue; // Min hold 30s
    long FCVP_type = PositionGetInteger(POSITION_TYPE);
    double FCVP_open = PositionGetDouble(POSITION_PRICE_OPEN);
    double FCVP_profit = PositionGetDouble(POSITION_PROFIT);
    double FCVP_current_sl = PositionGetDouble(POSITION_SL);
    double FCVP_current_tp = PositionGetDouble(POSITION_TP);
    double FCVP_new_sl = FCVP_current_sl;
    if (FCVP_UseVirtualSL) {
      double FCVP_current_price = (FCVP_type == POSITION_TYPE_BUY) ? FCVP_bid : FCVP_ask;
      if ((FCVP_type == POSITION_TYPE_BUY && FCVP_current_price <= FCVP_current_sl) ||
          (FCVP_type == POSITION_TYPE_SELL && FCVP_current_price >= FCVP_current_sl)) {
        FCVP_trade.PositionClose(FCVP_ticket);
        continue;
      }
    }
    double FCVP_rr_dist = (FCVP_type == POSITION_TYPE_BUY ? FCVP_bid - FCVP_open : FCVP_open - FCVP_ask);
    if (FCVP_rr_dist > FCVP_atr * 1.0) { // Partial at 1:1 RR
      double FCVP_close_lot = PositionGetDouble(POSITION_VOLUME) * (FCVP_PartialClosePct / 100.0);
      FCVP_trade.PositionClosePartial(FCVP_ticket, FCVP_close_lot);
    }
    if (FCVP_profit > FCVP_breakeven && FCVP_current_sl == 0.0) {
      FCVP_new_sl = (FCVP_type == POSITION_TYPE_BUY) ? FCVP_open + _Point : FCVP_open - _Point;
    }
    double FCVP_trail_dist = 0.0;
    if (StringCompare(FCVP_TrailingType, "ATR") == 0) {
      FCVP_trail_dist = FCVP_atr;
    } else if (StringCompare(FCVP_TrailingType, "Fixed") == 0) {
      FCVP_trail_dist = 20 * _Point;
    } else if (StringCompare(FCVP_TrailingType, "Swing") == 0) {
      FCVP_trail_dist = (FCVP_type == POSITION_TYPE_BUY) ? GetSwingLow(5) : GetSwingHigh(5);
    } else if (StringCompare(FCVP_TrailingType, "PSAR") == 0) {
      FCVP_new_sl = GetPSAR();
    } else if (StringCompare(FCVP_TrailingType, "Chandelier") == 0) {
      if (FCVP_profit > FCVP_TrailAfterPips * _Point) {
        double FCVP_chandelier = (FCVP_type == POSITION_TYPE_BUY) ? GetSwingHigh(22) - FCVP_atr * FCVP_ChandelierMulti : GetSwingLow(22) + FCVP_atr * FCVP_ChandelierMulti;
        FCVP_new_sl = (FCVP_type == POSITION_TYPE_BUY) ? FCVP_chandelier : FCVP_chandelier;
      }
    }
    if (FCVP_profit > FCVP_trail_dist) {
      if (FCVP_type == POSITION_TYPE_BUY) {
        FCVP_new_sl = FCVP_bid - FCVP_trail_dist;
      } else {
        FCVP_new_sl = FCVP_ask + FCVP_trail_dist;
      }
    }
    FCVP_new_sl = NormalizeDouble(FCVP_new_sl, _Digits);
    if (FCVP_type == POSITION_TYPE_BUY) {
      FCVP_new_sl = MathMin(FCVP_new_sl, FCVP_bid - FCVP_min_distance);
      if (FCVP_new_sl > FCVP_current_sl + FCVP_trail_step) {
        FCVP_trade.PositionModify(FCVP_ticket, FCVP_new_sl, FCVP_current_tp);
      }
    } else {
      FCVP_new_sl = MathMax(FCVP_new_sl, FCVP_ask + FCVP_min_distance);
      if (FCVP_new_sl < FCVP_current_sl - FCVP_trail_step || FCVP_current_sl == 0) {
        FCVP_trade.PositionModify(FCVP_ticket, FCVP_new_sl, FCVP_current_tp);
      }
    }
    bool FCVP_pyramid_condition = FCVP_profit > FCVP_PyramidMinPips * _Point && FCVP_Hurst > FCVP_HurstThreshold;
    if (FCVP_pyramid_condition) {
      PyramidOnWinner(FCVP_ticket);
    } else if (FCVP_DebugMode) {
      Print("Pyramid skipped: profit=", DoubleToString(FCVP_profit / _Point, 0), ", Hurst=", DoubleToString(FCVP_Hurst, 2));
    }
    if (CalculateForesightScore() < 0.4) FCVP_trade.PositionClose(FCVP_ticket);
  }
}
// GetSwingHigh
double GetSwingHigh(int bars) {
  if (bars < 3 || ArraySize(FCVP_rates) < bars) return 0.0;
  double high = 0.0;
  for (int i = 1; i <= bars; i++) {
    high = MathMax(high, FCVP_rates[i].high);
  }
  return high;
}
// GetSwingLow
double GetSwingLow(int bars) {
  if (bars < 3 || ArraySize(FCVP_rates) < bars) return 0.0;
  double low = DBL_MAX;
  for (int i = 1; i <= bars; i++) {
    low = MathMin(low, FCVP_rates[i].low);
  }
  return low;
}
// GetPSAR
double GetPSAR() {
  double FCVP_psar[1];
  if (CopyBuffer(FCVP_psar_handle, 0, 0, 1, FCVP_psar) <= 0) return 0.0;
  return FCVP_psar[0];
}
// IsTradingTime
bool IsTradingTime() {
  MqlDateTime FCVP_dt;
  TimeToStruct(TimeCurrent(), FCVP_dt);
  int FCVP_hour = FCVP_dt.hour + (FCVP_UseBrokerCST ? 0 : FCVP_TimeOffset);
  if (FCVP_hour < 0) FCVP_hour += 24;
  if (FCVP_hour >= 24) FCVP_hour -= 24;
  bool FCVP_in_session = (FCVP_hour >= FCVP_SessionStartHour && FCVP_hour < FCVP_SessionEndHour);
  if (FCVP_DebugMode && TimeCurrent() - FCVP_last_entry_debug > 300) {
    Print("Trading time check: ", FCVP_in_session ? "Yes" : "No", " (Hour: ", FCVP_hour, ")");
    FCVP_last_entry_debug = TimeCurrent();
  }
  return FCVP_in_session;
}
// IsPastSessionEnd15Min
bool IsPastSessionEnd15Min() {
  MqlDateTime FCVP_dt;
  TimeToStruct(TimeCurrent(), FCVP_dt);
  int FCVP_hour = FCVP_dt.hour + FCVP_TimeOffset;
  if (FCVP_hour < 0) FCVP_hour += 24;
  if (FCVP_hour >= 24) FCVP_hour -= 24;
  int FCVP_min = FCVP_dt.min;
  return (FCVP_hour > FCVP_SessionEndHour) || (FCVP_hour == FCVP_SessionEndHour && FCVP_min >= 15);
}
// IsHighVolPause
bool IsHighVolPause() {
  double FCVP_current_range = FCVP_rates[0].high - FCVP_rates[0].low;
  bool FCVP_high_vol = FCVP_current_range > 3.0 * FCVP_FHVV;
  bool FCVP_low_hurst = FCVP_Hurst < 0.5;
  bool FCVP_swan = FCVP_GARCH_Vol > FCVP_GARCHPauseThreshold;
  return FCVP_high_vol || FCVP_low_hurst || FCVP_swan;
}
// ArrayAvg
double ArrayAvg(double &arr[]) {
  double FCVP_sum = 0.0;
  int FCVP_size = ArraySize(arr);
  if (FCVP_size == 0) return 0.0;
  for (int i = 0; i < FCVP_size; i++) FCVP_sum += arr[i];
  return FCVP_sum / FCVP_size;
}
// StdDev
double StdDev(double &arr[]) {
  double FCVP_avg = ArrayAvg(arr);
  double FCVP_sum = 0.0;
  int FCVP_size = ArraySize(arr);
  if (FCVP_size <= 1) return 0.0;
  for (int i = 0; i < FCVP_size; i++) FCVP_sum += MathPow(arr[i] - FCVP_avg, 2);
  return MathSqrt(FCVP_sum / (FCVP_size - 1));
}
// UpdateWinLoss
void UpdateWinLoss() {
  FCVP_wins = 0;
  FCVP_losses = 0;
  HistorySelect(0, TimeCurrent());
  int FCVP_total = HistoryDealsTotal();
  int FCVP_start = MathMax(FCVP_total - 100, 0);
  for (int i = FCVP_start; i < FCVP_total; i++) {
    ulong FCVP_ticket = HistoryDealGetTicket(i);
    if (FCVP_ticket == 0) continue;
    if (HistoryDealGetString(FCVP_ticket, DEAL_SYMBOL) != _Symbol) continue;
    double FCVP_profit = HistoryDealGetDouble(FCVP_ticket, DEAL_PROFIT);
    if (FCVP_profit > 0) FCVP_wins++;
    else if (FCVP_profit < 0) FCVP_losses++;
  }
}
// EnterTrade
void EnterTrade(bool buy) {
  if (FCVP_FHVV < 0.0005) {
    if (FCVP_DebugMode) Print("Entry skipped: FHVV too low");
    return;
  }
  CTrade FCVP_trade;
  FCVP_trade.SetExpertMagicNumber(FCVP_next_magic++);
  double FCVP_atr = GetATR();
  double FCVP_sl_multi_adj = FCVP_SLMulti * (1.0 + FCVP_GARCH_Vol);
  double FCVP_sl_distance = (FCVP_FixedSLPips > 0) ? FCVP_FixedSLPips * _Point : FCVP_atr * FCVP_sl_multi_adj;
  double FCVP_tp_distance = (FCVP_FixedTPPips > 0) ? FCVP_FixedTPPips * _Point : FCVP_atr * FCVP_TPMulti;
  double FCVP_entry = buy ? SymbolInfoDouble(_Symbol, SYMBOL_ASK) : SymbolInfoDouble(_Symbol, SYMBOL_BID);
  double FCVP_sl = buy ? NormalizeDouble(FCVP_entry - FCVP_sl_distance, _Digits) : NormalizeDouble(FCVP_entry + FCVP_sl_distance, _Digits);
  double FCVP_tp = (FCVP_FixedTPPips > 0) ? (buy ? NormalizeDouble(FCVP_entry + FCVP_tp_distance, _Digits) : NormalizeDouble(FCVP_entry - FCVP_tp_distance, _Digits)) : 0.0; // 0 for trail-only
  double FCVP_lot = ScaledLotSize(FCVP_sl_distance / _Point);
  FCVP_trade.PositionOpen(_Symbol, buy ? ORDER_TYPE_BUY : ORDER_TYPE_SELL, FCVP_lot, 0.0, FCVP_sl, FCVP_tp, "Base");
  if (FCVP_trade.ResultRetcode() == TRADE_RETCODE_DONE) {
    DrawEntryArrow(buy);
  }
}
// HasHighImpactNews
bool HasHighImpactNews() {
  MqlCalendarValue FCVP_values[];
  datetime FCVP_from = TimeCurrent() - 86400LL;
  datetime FCVP_to = TimeCurrent() + 86400LL;
  if (!CalendarValueHistory(FCVP_values, FCVP_from, FCVP_to)) {
    Print("CalendarValueHistory failed - no news data");
    return false;
  }
  for (int i = 0; i < ArraySize(FCVP_values); i++) {
    MqlCalendarEvent FCVP_event;
    if (CalendarEventById(FCVP_values[i].event_id, FCVP_event)) {
      if (FCVP_event.importance >= CALENDAR_IMPORTANCE_HIGH) {
        MqlCalendarCountry FCVP_country;
        if (CalendarCountryById(FCVP_event.country_id, FCVP_country)) {
          if (StringCompare(FCVP_country.currency, "EUR") == 0 || StringCompare(FCVP_country.currency, "USD") == 0) {
            return true;
          }
        }
      }
    }
  }
  return false;
}
// PyramidOnWinner
void PyramidOnWinner(ulong ticket) {
  if (!PositionSelectByTicket(ticket)) return;
  long FCVP_parent_magic = PositionGetInteger(POSITION_MAGIC);
  if (FCVP_parent_magic == 0) return;
  long FCVP_type_long = PositionGetInteger(POSITION_TYPE);
  double FCVP_sl = PositionGetDouble(POSITION_SL);
  double FCVP_tp = PositionGetDouble(POSITION_TP);
  double FCVP_volume = PositionGetDouble(POSITION_VOLUME);
  double FCVP_add_lot = FCVP_volume * 0.5;
  // Count positions with same magic
  int FCVP_pyramid_count = 0;
  for (int j = PositionsTotal() - 1; j >= 0; j--) {
    ulong FCVP_pos_ticket = PositionGetTicket(j);
    if (FCVP_pos_ticket == 0) continue;
    if (PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
    long FCVP_pos_magic = PositionGetInteger(POSITION_MAGIC);
    if (FCVP_pos_magic == FCVP_parent_magic) FCVP_pyramid_count++;
  }
  if (FCVP_pyramid_count >= 1 + FCVP_MaxPyramids) return;
  CTrade FCVP_trade;
  FCVP_trade.SetExpertMagicNumber(FCVP_parent_magic);
  FCVP_trade.PositionOpen(_Symbol, (ENUM_ORDER_TYPE)FCVP_type_long, FCVP_add_lot, 0.0, FCVP_sl, FCVP_tp, "Pyramid");
}
// CalculateDrawdown
double CalculateDrawdown() {
  double FCVP_balance = AccountInfoDouble(ACCOUNT_BALANCE);
  double FCVP_equity = AccountInfoDouble(ACCOUNT_EQUITY);
  if (FCVP_balance == 0.0) return 0.0;
  return (FCVP_balance - FCVP_equity) / FCVP_balance * 100.0;
}
// CloseAllPositions
void CloseAllPositions() {
  CTrade FCVP_trade;
  for (int i = PositionsTotal() - 1; i >= 0; i--) {
    ulong FCVP_ticket = PositionGetTicket(i);
    if (FCVP_ticket > 0 && PositionGetString(POSITION_SYMBOL) == _Symbol) {
      FCVP_trade.PositionClose(FCVP_ticket);
    }
  }
}
// Integrated VWAP: CreateDateTime
datetime FCVP_VWAP_CreateDateTime(FCVP_VWAP_DATE_TYPE nReturnType=FCVP_VWAP_DATE_TYPE::FCVP_VWAP_DAILY, datetime dtDay=D'2000.01.01 00:00:00', int pHour=0, int pMinute=0, int pSecond=0) {
  datetime dtReturnDate;
  MqlDateTime timeStruct;
  TimeToStruct(dtDay, timeStruct);
  timeStruct.hour = pHour;
  timeStruct.min = pMinute;
  timeStruct.sec = pSecond;
  dtReturnDate = StructToTime(timeStruct);
  if (nReturnType == FCVP_VWAP_DATE_TYPE::FCVP_VWAP_WEEKLY) {
    while (timeStruct.day_of_week != 0) {
      dtReturnDate = dtReturnDate - 86400;
      TimeToStruct(dtReturnDate, timeStruct);
    }
  }
  if (nReturnType == FCVP_VWAP_DATE_TYPE::FCVP_VWAP_MONTHLY) {
    timeStruct.day = 1;
    dtReturnDate = StructToTime(timeStruct);
  }
  return dtReturnDate;
}
// Integrated VWAP: Compute
void FCVP_VWAP_Compute() {
  int rates_total = ArraySize(FCVP_rates);
  if (rates_total <= 0) return;
  if (FCVP_VWAP_IsFirstRun || _Period != FCVP_VWAP_LastTimePeriod) {
    FCVP_VWAP_IsFirstRun = false;
    FCVP_VWAP_LastTimePeriod = _Period;
    int max_rates = 10000;
    ArrayResize(FCVP_VWAP_PriceArr, max_rates);
    ArrayResize(FCVP_VWAP_TotalTPV, max_rates);
    ArrayResize(FCVP_VWAP_TotalVol, max_rates);
    ArrayResize(FCVP_VWAP_Buffer_Daily, max_rates);
    ArrayResize(FCVP_VWAP_Buffer_Weekly, max_rates);
    ArrayResize(FCVP_VWAP_Buffer_Monthly, max_rates);
    FCVP_VWAP_SumDailyTPV = 0;
    FCVP_VWAP_SumDailyVol = 0;
    FCVP_VWAP_SumWeeklyTPV = 0;
    FCVP_VWAP_SumWeeklyVol = 0;
    FCVP_VWAP_SumMonthlyTPV = 0;
    FCVP_VWAP_SumMonthlyVol = 0;
  }
  if (ArraySize(FCVP_VWAP_PriceArr) < rates_total) {
    ArrayResize(FCVP_VWAP_PriceArr, rates_total);
    ArrayResize(FCVP_VWAP_TotalTPV, rates_total);
    ArrayResize(FCVP_VWAP_TotalVol, rates_total);
    ArrayResize(FCVP_VWAP_Buffer_Daily, rates_total);
    ArrayResize(FCVP_VWAP_Buffer_Weekly, rates_total);
    ArrayResize(FCVP_VWAP_Buffer_Monthly, rates_total);
  }
  for (int i = 0; i < rates_total; i++) {
    switch (FCVP_VWAP_Price_Type) {
      case FCVP_OPEN:
        FCVP_VWAP_PriceArr[i] = FCVP_rates[i].open;
        break;
      case FCVP_CLOSE:
        FCVP_VWAP_PriceArr[i] = FCVP_rates[i].close;
        break;
      case FCVP_HIGH:
        FCVP_VWAP_PriceArr[i] = FCVP_rates[i].high;
        break;
      case FCVP_LOW:
        FCVP_VWAP_PriceArr[i] = FCVP_rates[i].low;
        break;
      case FCVP_OPEN_CLOSE:
        FCVP_VWAP_PriceArr[i] = (FCVP_rates[i].open + FCVP_rates[i].close) / 2;
        break;
      case FCVP_HIGH_LOW:
        FCVP_VWAP_PriceArr[i] = (FCVP_rates[i].high + FCVP_rates[i].low) / 2;
        break;
      case FCVP_CLOSE_HIGH_LOW:
        FCVP_VWAP_PriceArr[i] = (FCVP_rates[i].close + FCVP_rates[i].high + FCVP_rates[i].low) / 3;
        break;
      case FCVP_OPEN_CLOSE_HIGH_LOW:
        FCVP_VWAP_PriceArr[i] = (FCVP_rates[i].open + FCVP_rates[i].close + FCVP_rates[i].high + FCVP_rates[i].low) / 4;
        break;
    }
    FCVP_VWAP_TotalTPV[i] = FCVP_VWAP_PriceArr[i] * (double)FCVP_rates[i].tick_volume;
    FCVP_VWAP_TotalVol[i] = (double)FCVP_rates[i].tick_volume;
    if (FCVP_VWAP_Enable_Daily) {
      if (FCVP_VWAP_CreateDateTime(FCVP_VWAP_DATE_TYPE::FCVP_VWAP_DAILY, FCVP_rates[i].time) != FCVP_VWAP_LastDay) {
        FCVP_VWAP_IdxDaily = i;
        FCVP_VWAP_SumDailyTPV = 0;
        FCVP_VWAP_SumDailyVol = 0;
      }
      FCVP_VWAP_SumDailyTPV += FCVP_VWAP_TotalTPV[i];
      FCVP_VWAP_SumDailyVol += FCVP_VWAP_TotalVol[i];
      FCVP_VWAP_Buffer_Daily[i] = (FCVP_VWAP_SumDailyVol > 0) ? FCVP_VWAP_SumDailyTPV / FCVP_VWAP_SumDailyVol : 0.0;
      FCVP_VWAP_Current = FCVP_VWAP_Buffer_Daily[i]; // Use daily for bias
      FCVP_VWAP_LastDay = FCVP_VWAP_CreateDateTime(FCVP_VWAP_DATE_TYPE::FCVP_VWAP_DAILY, FCVP_rates[i].time);
    }
    // Similar for weekly and monthly if enabled
    if (FCVP_VWAP_Enable_Weekly) {
      if (FCVP_VWAP_CreateDateTime(FCVP_VWAP_DATE_TYPE::FCVP_VWAP_WEEKLY, FCVP_rates[i].time) != FCVP_VWAP_LastWeek) {
        FCVP_VWAP_IdxWeekly = i;
        FCVP_VWAP_SumWeeklyTPV = 0;
        FCVP_VWAP_SumWeeklyVol = 0;
      }
      FCVP_VWAP_SumWeeklyTPV += FCVP_VWAP_TotalTPV[i];
      FCVP_VWAP_SumWeeklyVol += FCVP_VWAP_TotalVol[i];
      FCVP_VWAP_Buffer_Weekly[i] = (FCVP_VWAP_SumWeeklyVol > 0) ? FCVP_VWAP_SumWeeklyTPV / FCVP_VWAP_SumWeeklyVol : 0.0;
      FCVP_VWAP_LastWeek = FCVP_VWAP_CreateDateTime(FCVP_VWAP_DATE_TYPE::FCVP_VWAP_WEEKLY, FCVP_rates[i].time);
    }
    if (FCVP_VWAP_Enable_Monthly) {
      if (FCVP_VWAP_CreateDateTime(FCVP_VWAP_DATE_TYPE::FCVP_VWAP_MONTHLY, FCVP_rates[i].time) != FCVP_VWAP_LastMonth) {
        FCVP_VWAP_IdxMonthly = i;
        FCVP_VWAP_SumMonthlyTPV = 0;
        FCVP_VWAP_SumMonthlyVol = 0;
      }
      FCVP_VWAP_SumMonthlyTPV += FCVP_VWAP_TotalTPV[i];
      FCVP_VWAP_SumMonthlyVol += FCVP_VWAP_TotalVol[i];
      FCVP_VWAP_Buffer_Monthly[i] = (FCVP_VWAP_SumMonthlyVol > 0) ? FCVP_VWAP_SumMonthlyTPV / FCVP_VWAP_SumMonthlyVol : 0.0;
      FCVP_VWAP_LastMonth = FCVP_VWAP_CreateDateTime(FCVP_VWAP_DATE_TYPE::FCVP_VWAP_MONTHLY, FCVP_rates[i].time);
    }
  }
}
