<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SPX Mastery Long-Term Options Analyzer (Build 1, Version 20)</title>
    <link rel="icon" href="https://storage.googleapis.com/msgsndr/DbcHU95N4uVVUJoOWctG/media/68c18e9983b98269408909db.png">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js" onload="console.log('CDN_SUCCESS_1: jsDelivr loaded')" onerror="console.log('CDN_ERROR_1: jsDelivr failed'); loadFallbackCDN(1)"></script>
    <script>
        function loadFallbackCDN(attempt) {
            console.log(`Loading fallback CDN ${attempt}`);
            const fallbackScript = document.createElement('script');
            fallbackScript.src = attempt === 1 ? 'https://cdnjs.cloudflare.com/ajax/libs/chart.js/4.4.4/chart.min.js' : 'https://unpkg.com/chart.js@4.4.4/dist/chart.min.js';
            fallbackScript.onload = () => console.log(`CDN_SUCCESS_${attempt + 1}: Fallback loaded`);
            fallbackScript.onerror = () => {
                console.log(`CDN_ERROR_${attempt + 1}: Fallback failed`);
                if (attempt === 1) loadFallbackCDN(2);
                else {
                    console.log('All CDNs failed - charts disabled');
                    document.getElementById('chartError').style.display = 'block';
                    document.getElementById('chartError').innerText = 'CDN_ERROR_ALL: All Chart.js CDNs failed. Disable ad blockers or try incognito mode.';
                }
            };
            document.head.appendChild(fallbackScript);
        }
    </script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background-color: #f4f4f4; }
        h1, h2, h3 { color: #333; text-align: center; }
        .input-section { background: white; padding: 20px; margin: 20px auto; max-width: 800px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        .input-group { display: flex; justify-content: space-around; margin: 10px 0; flex-wrap: wrap; }
        input, select { padding: 5px; width: 120px; }
        button { padding: 10px 20px; background: #4CAF50; color: white; border: none; cursor: pointer; margin: 2px; }
        button:disabled { background: #ccc; cursor: not-allowed; }
        .current-greeks { text-align: center; margin: 10px; font-weight: bold; }
        .chart-container, .table-container, .chain-container { width: 100%; max-width: 800px; margin: 20px auto; background: white; padding: 20px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        canvas { max-height: 300px; width: 100% !important; height: 300px !important; }
        table { border-collapse: collapse; width: 100%; margin: 20px 0; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: center; }
        th { background-color: #4CAF50; color: white; }
        tr:nth-child(even) { background-color: #f2f2f2; }
        tr:hover { background-color: #e8f5e8; }
        .current-row { background-color: #fff3cd; font-weight: bold; }
        .profit-row { background-color: #d4edda; }
        .high-profit-row { background-color: #c3e6cb; }
        .suggested-row { background-color: #add8e6; }
        p { margin-top: 20px; font-size: 14px; color: #666; text-align: center; }
        .legend { text-align: center; margin: 10px 0; }
        .teal { color: teal; font-weight: bold; }
        .orange { color: orange; font-weight: bold; }
        .purple { color: purple; font-weight: bold; }
        .error { color: purple; text-align: center; }
        .disclaimer { background: #fff3cd; padding: 15px; margin: 20px auto; max-width: 800px; border: 1px solid #ffcc00; text-align: center; font-size: 12px; }
        .finra-disclosure { background: #f8f9fa; padding: 20px; margin: 20px auto; max-width: 800px; border: 1px solid #ccc; font-size: 12px; text-align: left; }
        .api-section { margin: 10px 0; text-align: center; }
        .api-input { width: 200px; padding: 5px; }
        .contango { color: teal; font-weight: bold; }
        .backwardation { color: purple; font-weight: bold; }
        .flat { color: orange; font-weight: bold; }
        .fetch-success { color: teal; text-align: center; margin: 10px; }
        .version { font-size: 12px; color: #666; text-align: center; margin-top: 20px; }
        .api-note { font-size: 12px; color: #666; text-align: center; margin: 5px 0; }
        .after-hours { color: orange; font-style: italic; text-align: center; margin: 5px 0; }
        .tradingview-container { display: flex; justify-content: space-around; flex-wrap: wrap; max-width: 800px; margin: 20px auto; }
        #tradingview_spx, #tradingview_vix { width: 300px; height: 300px; }
    </style>
</head>
<body>
    <p style="text-align: center; font-size: 12px;">Copyright Â© SPXMASTERY.com Russell Clark All Rights Reserved</p>
    <a href="#finra-disclosure" style="text-align: center; display: block; font-size: 12px;">View Full FINRA Options Disclosure</a>
    <div class="disclaimer">
        <strong>Disclaimer:</strong> This tool is for educational purposes only and is not financial advice. Options trading involves significant risks, including the potential loss of your entire investment or more. Calculations are theoretical (Black-Scholes model) and may not reflect actual market conditions. The creator (spxmastery) is not liable for any financial losses or damages resulting from use of this tool. Consult a qualified financial advisor before trading options.
    </div>
    <h1>SPX Mastery Long-Term Options Analyzer (Build 1, Version 20)</h1>
    <div class="input-section">
        <h2>Input Parameters (Click Update to Recalculate)</h2>
        <div class="api-section">
            <label>API Key: <input id="apiKey" type="password" class="api-input" placeholder="Enter Polygon Key" value="85b67707-e8e2-4fc4-91d4-073cf4308739"></label>
            <label>Provider: <select id="apiProvider"><option value="polygon">Polygon</option><option value="alpha">Alpha Vantage</option><option value="finnhub">Finnhub</option></select></label>
            <button id="fetchLiveBtn" onclick="fetchLiveData()">Fetch Live Data</button>
            <button id="fetchChainBtn" onclick="fetchOptionsChain()">Fetch Options Chain</button>
            <p class="api-note">Polygon tier: Indices/Options. Use for live SPX/VIX/chain. After-hours: Shows last close.</p>
        </div>
        <div class="input-group">
            <label>SPX Price: <input id="spx" type="number" value="6550" step="0.01"></label>
            <label>Strike (K): <input id="strike" type="number" value="7000"></label>
            <label>Expiration (YYYY-MM-DD): <input id="expiration" type="date" value="2025-11-28"></label>
            <label>IV (%): <input id="iv" type="number" value="15" step="0.01"></label>
        </div>
        <div class="input-group">
            <label>Premium: <input id="premium" type="number" value="13.75" step="0.01"></label>
            <label>Contracts: <input id="contracts" type="number" value="10" min="1"></label>
            <label>Risk-Free Rate (r %): <input id="r" type="number" value="3.8" step="0.01"></label>
            <label>Dividend Yield (q %): <input id="q" type="number" value="1.3" step="0.01"></label>
        </div>
        <div class="input-group">
            <label>EDR Days: <input id="edrDays" type="number" value="30" step="1"></label>
            <button onclick="setEdrDays(30)">30 Days</button>
            <button onclick="setEdrDays(60)">60 Days</button>
            <button onclick="setEdrDays(90)">90 Days</button>
            <label>Custom EDR (%): <input id="customEdr" type="number" placeholder="Override" step="0.01"></label>
        </div>
        <div class="input-group">
            <label>IV Source: <select id="ivSource"><option value="manual">Manual</option><option value="live">Live</option></select></label>
            <label>Option Type: <select id="optionType"><option value="call">Call</option><option value="put">Put</option></select></label>
            <button onclick="updateAll()">Update</button>
            <button onclick="applyEtfProxy()">ETF Proxy</button>
        </div>
        <p id="afterHoursNote" class="after-hours" style="display: block;">After-Hours: Data is last close (4:00 PM EDT).</p>
        <p id="contangoStatus"></p>
        <div id="currentGreeks" class="current-greeks"></div>
        <div id="dteForecast" class="table-container">
            <h3>DTE Forecast (Theta Burn, Vega Sensitivity)</h3>
            <table id="dteTable">
                <thead><tr><th>DTE</th><th>Theta (Proj)</th><th>Vega (Proj)</th><th>Notes</th></tr></thead>
                <tbody></tbody>
            </table>
        </div>
        <div class="tradingview-container">
            <div id="tradingview_spx"></div>
            <div id="tradingview_vix"></div>
        </div>
    </div>
    <div class="chain-container" id="chainContainer" style="display: none;">
        <h3>Options Chain (Select Row for Strike/Premium/IV)</h3>
        <table id="chainTable">
            <thead><tr><th>Strike</th><th>Bid</th><th>Ask</th><th>Mid</th><th>IV (%)</th><th>Delta</th><th>Gamma</th><th>Theta</th><th>Vega</th></tr></thead>
            <tbody></tbody>
        </table>
        <p>Suggested: Highlighted rows have delta 0.4-0.6 (balanced for vol plays/short-term trades).</p>
    </div>
    <div class="table-container">
        <h2>Position Analysis</h2>
        <table id="positionTable">
            <thead><tr><th>Scenario</th><th>SPX Needed</th><th>Delta</th><th>Gamma</th><th>Theta</th><th>Vega</th><th>Price</th><th>P/L ($)</th></tr></thead>
            <tbody></tbody>
        </table>
    </div>
    <div class="chart-container">
        <h2>Greeks Charts (Blue: Value, Teal: Good Threshold, Purple: Warning Threshold, Vertical: Current SPX)</h2>
        <div id="chartError" class="error" style="display: none;"></div>
        <canvas id="deltaChart"></canvas>
        <canvas id="gammaChart"></canvas>
        <canvas id="thetaChart"></canvas>
        <canvas id="vegaChart"></canvas>
        <p class="legend"><span class="teal">Favorable</span> | <span class="orange">Caution</span> | <span class="purple">Risky</span></p>
    </div>
    <script src="https://s3.tradingview.com/tv.js"></script>
    <script>
        new TradingView.widget({
            "container_id": "tradingview_spx",
            "width": 300,
            "height": 300,
            "symbol": "US500",
            "interval": "D",
            "timezone": "America/New_York",
            "theme": "light",
            "style": "1",
            "locale": "en",
            "toolbar_bg": "#f1f3f6",
            "enable_publishing": false,
            "allow_symbol_change": true,
            "studies": ["STD;VIX"]
        });
        new TradingView.widget({
            "container_id": "tradingview_vix",
            "width": 300,
            "height": 300,
            "symbol": "CBOE:VIX",
            "interval": "D",
            "timezone": "America/New_York",
            "theme": "light",
            "style": "1",
            "locale": "en",
            "toolbar_bg": "#f1f3f6",
            "enable_publishing": false,
            "allow_symbol_change": true
        });
    </script>
    <script>
        // Black-Scholes Functions
        function normCDF(x) {
            const t = 1 / (1 + 0.2316419 * Math.abs(x));
            const d = 0.3989423 * Math.exp(-x * x / 2);
            let prob = d * t * (0.3193815 + t * (-0.3565638 + t * (1.781478 + t * (-1.821256 + t * 1.330274))));
            if (x > 0) return 1 - prob;
            return prob;
        }
        function blackScholesGreeks(S, K, T, r, sigma, q = 0, type = 'call') {
            if (T <= 0) return { price: type === 'call' ? Math.max(S - K, 0) : Math.max(K - S, 0), delta: 0, gamma: 0, theta: 0, vega: 0 };
            const d1 = (Math.log(S / K) + (r - q + sigma ** 2 / 2) * T) / (sigma * Math.sqrt(T));
            const d2 = d1 - sigma * Math.sqrt(T);
            const nd1 = normCDF(d1);
            const nd2 = normCDF(d2);
            const nnd1 = normCDF(-d1);
            const nnd2 = normCDF(-d2);
            let price, delta, gamma, theta, vega;
            if (type === 'call') {
                price = S * Math.exp(-q * T) * nd1 - K * Math.exp(-r * T) * nd2;
                delta = Math.exp(-q * T) * nd1;
            } else {
                price = K * Math.exp(-r * T) * nnd2 - S * Math.exp(-q * T) * nnd1;
                delta = -Math.exp(-q * T) * nnd1;
            }
            gamma = Math.exp(-q * T) / (S * sigma * Math.sqrt(T)) * (1 / Math.sqrt(2 * Math.PI)) * Math.exp(-d1 ** 2 / 2);
            theta = - (S * Math.exp(-q * T) * (1 / Math.sqrt(2 * Math.PI)) * Math.exp(-d1 ** 2 / 2) * sigma) / (2 * Math.sqrt(T)) - r * K * Math.exp(-r * T) * (type === 'call' ? nd2 : -nnd2) + q * S * Math.exp(-q * T) * (type === 'call' ? nd1 : -nnd1);
            theta /= 252; // Trading days
            vega = S * Math.exp(-q * T) * Math.sqrt(T) * (1 / Math.sqrt(2 * Math.PI)) * Math.exp(-d1 ** 2 / 2) / 100;
            return { price, delta, gamma, theta, vega };
        }
        function solveForS(targetPrice, currentS, K, T, r, sigma, q, type, contracts, tolerance = 0.01) {
            let low = currentS * 0.5;
            let high = currentS * 1.5;
            let mid;
            while (high - low > tolerance) {
                mid = (low + high) / 2;
                const greeks = blackScholesGreeks(mid, K, T, r, sigma, q, type);
                if (greeks.price * contracts * 100 < targetPrice * contracts * 100) low = mid;
                else high = mid;
            }
            return mid.toFixed(2);
        }
        function calculateDTE(expDate) {
            const today = new Date();
            const exp = new Date(expDate);
            return Math.max((exp - today) / (1000 * 60 * 60 * 24) / 365, 0.0001); // Avoid T=0
        }
        function validateInputs() {
            const inputs = ['spx', 'strike', 'iv', 'premium', 'contracts', 'r', 'q', 'edrDays'];
            for (let id of inputs) {
                const val = parseFloat(document.getElementById(id).value);
                if (isNaN(val) || val <= 0) {
                    document.getElementById('currentGreeks').innerHTML = `<span class="error">Invalid input for ${id.toUpperCase()}. Must be positive number.</span>`;
                    return false;
                }
            }
            return true;
        }
        async function fetchLiveData(attempt = 1, maxAttempts = 3) {
            if (!validateInputs()) return;
            const fetchBtn = document.getElementById('fetchLiveBtn');
            fetchBtn.disabled = true;
            fetchBtn.innerText = 'Fetching...';
            try {
                const provider = document.getElementById('apiProvider').value;
                const apiKey = document.getElementById('apiKey').value;
                if (!apiKey) throw new Error('API_ERROR_NO_KEY: Enter valid key.');
                console.log('API_FETCH_START: Provider', provider, 'Attempt', attempt);
                localStorage.setItem('apiKey', apiKey);
                localStorage.setItem('apiProvider', provider);
                const now = new Date();
                const etOffset = -4; // EDT
                const etTime = new Date(now.getTime() + etOffset * 60 * 60 * 1000);
                const etHour = etTime.getHours();
                const etMin = etTime.getMinutes();
                const isAfterHours = etHour < 9 || (etHour === 9 && etMin < 30) || etHour >= 16;
                document.getElementById('afterHoursNote').style.display = isAfterHours ? 'block' : 'none';
                let spxPrice, vixSpot;
                if (provider === 'polygon') {
                    const spxResp = await fetch(`https://api.polygon.io/v2/aggs/ticker/I:SPX/prev?apiKey=${apiKey}`);
                    const spxData = await spxResp.json();
                    if (!spxResp.ok) throw new Error(`API_ERROR_SPX_HTTP_${spxResp.status}: Check API key permissions or Indices subscription.`);
                    if (!spxData.results?.[0]?.c) throw new Error('API_ERROR_NO_SPX: Empty SPX response');
                    spxPrice = spxData.results[0].c; // Use prev.close
                    const vixResp = await fetch(`https://api.polygon.io/v2/aggs/ticker/I:VIX/prev?apiKey=${apiKey}`);
                    const vixData = await vixResp.json();
                    if (!vixResp.ok) throw new Error(`API_ERROR_VIX_HTTP_${vixResp.status}: Check API key permissions or Indices subscription.`);
                    if (!vixData.results?.[0]?.c) throw new Error('API_ERROR_NO_VIX: Empty VIX response');
                    vixSpot = vixData.results[0].c; // Use prev.close
                    console.log('Polygon SPX:', spxData, 'VIX:', vixData);
                } else if (provider === 'alpha') {
                    const spxUrl = `https://www.alphavantage.co/query?function=GLOBAL_QUOTE&symbol=^GSPC&apikey=${apiKey}`;
                    const spxData = await (await fetch(spxUrl)).json();
                    if (!spxData['Global Quote']) throw new Error('API_ERROR_ALPHA_SPX: Invalid response');
                    spxPrice = parseFloat(spxData['Global Quote']['05. price']);
                    const vixUrl = `https://www.alphavantage.co/query?function=GLOBAL_QUOTE&symbol=^VIX&apikey=${apiKey}`;
                    const vixData = await (await fetch(vixUrl)).json();
                    if (!vixData['Global Quote']) throw new Error('API_ERROR_ALPHA_VIX: Invalid response');
                    vixSpot = parseFloat(vixData['Global Quote']['05. price']);
                } else {
                    const spxUrl = `https://finnhub.io/api/v1/quote?symbol=^GSPC&token=${apiKey}`;
                    const spxData = await (await fetch(spxUrl)).json();
                    if (!spxData.c) throw new Error('API_ERROR_FINNHUB_SPX: Invalid response');
                    spxPrice = spxData.c;
                    const vixUrl = `https://finnhub.io/api/v1/quote?symbol=^VIX&token=${apiKey}`;
                    const vixData = await (await fetch(vixUrl)).json();
                    if (!vixData.c) throw new Error('API_ERROR_FINNHUB_VIX: Invalid response');
                    vixSpot = vixData.c;
                }
                if (!spxPrice || isNaN(spxPrice)) throw new Error('API_ERROR_INVALID_SPX: No valid SPX price');
                document.getElementById('spx').value = spxPrice.toFixed(2);
                if (document.getElementById('ivSource').value === 'live' && vixSpot && !isNaN(vixSpot)) {
                    const T = calculateDTE(document.getElementById('expiration').value);
                    const calibratedIV = (vixSpot / 100) * Math.sqrt(30 / (T * 365));
                    document.getElementById('iv').value = (calibratedIV * 100).toFixed(2);
                }
                let contangoStatus = 'Contango Unknown';
                if (provider === 'polygon' && vixSpot && !isNaN(vixSpot)) {
                    const futRefResp = await fetch(`https://api.polygon.io/v3/reference/futures/contracts?underlying=VIX&expired=false&limit=1&sort=expiration_date&order=asc&apiKey=${apiKey}`);
                    const futRef = await futRefResp.json();
                    if (!futRefResp.ok) throw new Error(`API_ERROR_FUTURES_HTTP_${futRefResp.status}: Check API key permissions.`);
                    const frontTicker = futRef.results?.[0]?.ticker;
                    if (frontTicker) {
                        const futResp = await fetch(`https://api.polygon.io/v3/snapshot/futures?ticker=${frontTicker}&apiKey=${apiKey}`);
                        const futData = await futResp.json();
                        if (!futResp.ok) throw new Error(`API_ERROR_FUTURES_SNAPSHOT_HTTP_${futResp.status}: Check API key permissions.`);
                        const futurePrice = futData.results?.[0]?.value || futData.results?.[0]?.prev_close;
                        if (futurePrice) {
                            const ratio = futurePrice / vixSpot;
                            if (ratio > 1.02) contangoStatus = `<span class="contango">Contango (${ratio.toFixed(2)}): Buy/Hold Favorable for Long-Term</span>`;
                            else if (ratio < 0.98) contangoStatus = `<span class="backwardation">Backwardation (${ratio.toFixed(2)}): Vol Spike Risk - Short-Term/Cash Out</span>`;
                            else contangoStatus = `<span class="flat">Flat (${ratio.toFixed(2)}): Neutral Market</span>`;
                        }
                    }
                }
                document.getElementById('contangoStatus').innerHTML = contangoStatus;
                document.getElementById('currentGreeks').innerHTML = '<span class="fetch-success">Fetch Success: SPX/VIX/Contango Updated.</span>';
                updateAll();
            } catch (e) {
                console.log('API_FETCH_ERROR:', e.message, e.stack);
                document.getElementById('currentGreeks').innerHTML = `<span class="error">API_ERROR: ${e.message}. Retry ${attempt}/${maxAttempts}. Check API key permissions or Indices/Options subscription. See console (F12).</span>`;
                if (attempt < maxAttempts) {
                    setTimeout(() => fetchLiveData(attempt + 1), 2000);
                } else {
                    document.getElementById('currentGreeks').innerHTML += '<br><span class="error">All retries failed. Using fallback data.</span>';
                    applyEtfProxy();
                }
            } finally {
                fetchBtn.disabled = false;
                fetchBtn.innerText = 'Fetch Live Data';
            }
        }
        async function fetchOptionsChain() {
            const fetchBtn = document.getElementById('fetchChainBtn');
            fetchBtn.disabled = true;
            fetchBtn.innerText = 'Fetching Chain...';
            try {
                const apiKey = document.getElementById('apiKey').value;
                const exp = document.getElementById('expiration').value;
                const type = document.getElementById('optionType').value;
                if (document.getElementById('apiProvider').value !== 'polygon') throw new Error('Chain fetch only for Polygon.');
                const url = `https://api.polygon.io/v3/snapshot/options/SPX?expiration_date=${exp}&contract_type=${type}&order=asc&limit=100&sort=strike_price&apiKey=${apiKey}`;
                const resp = await fetch(url);
                if (!resp.ok) throw new Error(`API_ERROR_CHAIN_HTTP_${resp.status}: Check API key permissions or Options subscription.`);
                const data = await resp.json();
                if (!data.results?.length) throw new Error('API_ERROR_NO_CHAIN: No options data for selected expiration');
                const tableBody = document.getElementById('chainTable').querySelector('tbody');
                tableBody.innerHTML = '';
                data.results.forEach(opt => {
                    const mid = (opt.last_quote.bid + opt.last_quote.ask) / 2;
                    const row = document.createElement('tr');
                    row.innerHTML = `<td>${opt.details.strike_price}</td><td>${opt.last_quote.bid}</td><td>${opt.last_quote.ask}</td><td>${mid.toFixed(2)}</td><td>${(opt.implied_volatility * 100).toFixed(2)}</td><td>${opt.greeks.delta.toFixed(2)}</td><td>${opt.greeks.gamma.toFixed(2)}</td><td>${opt.greeks.theta.toFixed(2)}</td><td>${opt.greeks.vega.toFixed(2)}</td>`;
                    if (opt.greeks.delta >= 0.4 && opt.greeks.delta <= 0.6) row.classList.add('suggested-row');
                    row.onclick = () => {
                        document.getElementById('strike').value = opt.details.strike_price;
                        document.getElementById('premium').value = mid.toFixed(2);
                        document.getElementById('iv').value = (opt.implied_volatility * 100).toFixed(2);
                        updateAll();
                    };
                    tableBody.appendChild(row);
                });
                document.getElementById('chainContainer').style.display = 'block';
                document.getElementById('currentGreeks').innerHTML = '<span class="fetch-success">Options Chain Loaded.</span>';
            } catch (e) {
                console.log('CHAIN_FETCH_ERROR:', e.message, e.stack);
                document.getElementById('currentGreeks').innerHTML = `<span class="error">Chain Fetch Error: ${e.message}. Check expiration/API key permissions/console (F12).</span>`;
            } finally {
                fetchBtn.disabled = false;
                fetchBtn.innerText = 'Fetch Options Chain';
            }
        }
        async function applyEtfProxy() {
            const fetchBtn = document.getElementById('fetchLiveBtn');
            fetchBtn.disabled = true;
            fetchBtn.innerText = 'Fetching Proxy...';
            try {
                const apiKey = document.getElementById('apiKey').value;
                const provider = document.getElementById('apiProvider').value;
                let spyUrl, uvxyUrl;
                if (provider === 'polygon') {
                    spyUrl = `https://api.polygon.io/v2/aggs/ticker/SPY/prev?apiKey=${apiKey}`;
                    uvxyUrl = `https://api.polygon.io/v2/aggs/ticker/UVXY/prev?apiKey=${apiKey}`;
                } else {
                    throw new Error('Proxy only for Polygon');
                }
                const spyResp = await fetch(spyUrl);
                if (!spyResp.ok) throw new Error(`API_ERROR_SPY_HTTP_${spyResp.status}: Check API key permissions.`);
                const spyData = await spyResp.json();
                if (!spyData.results?.[0]?.c) throw new Error('API_ERROR_NO_SPY: Empty response');
                const spxPrice = spyData.results[0].c * 10;
                document.getElementById('spx').value = spxPrice.toFixed(2);
                const uvxyResp = await fetch(uvxyUrl);
                if (!uvxyResp.ok) throw new Error(`API_ERROR_UVXY_HTTP_${uvxyResp.status}: Check API key permissions.`);
                const uvxyData = await uvxyResp.json();
                if (!uvxyData.results?.[0]?.c) throw new Error('API_ERROR_NO_UVXY: Empty response');
                const ivApprox = uvxyData.results[0].c * 1.5; // Approximate IV
                if (document.getElementById('ivSource').value === 'live') document.getElementById('iv').value = ivApprox.toFixed(2);
                document.getElementById('currentGreeks').innerHTML = '<span class="fetch-success">ETF Proxy Applied: SPX/VIX Updated.</span>';
                updateAll();
            } catch (e) {
                console.log('PROXY_ERROR:', e.message, e.stack);
                document.getElementById('currentGreeks').innerHTML = `<span class="error">Proxy Error: ${e.message}. Using default values.</span>`;
            } finally {
                fetchBtn.disabled = false;
                fetchBtn.innerText = 'Fetch Live Data';
            }
        }
        function updateAll() {
            if (!validateInputs()) return;
            try {
                const S = parseFloat(document.getElementById('spx').value) || 6550;
                const K = parseFloat(document.getElementById('strike').value) || 7000;
                const expDate = document.getElementById('expiration').value || '2025-11-28';
                const T = calculateDTE(expDate);
                const sigma = (parseFloat(document.getElementById('iv').value) || 15) / 100;
                const r = (parseFloat(document.getElementById('r').value) || 3.8) / 100;
                const q = (parseFloat(document.getElementById('q').value) || 1.3) / 100;
                const premium = parseFloat(document.getElementById('premium').value) || 13.75;
                const contracts = parseInt(document.getElementById('contracts').value) || 10;
                const type = document.getElementById('optionType').value;
                const greeks = blackScholesGreeks(S, K, T, r, sigma, q, type);
                let currentGreeksHtml = `Current Greeks: Delta <span class="${greeks.delta > 0.6 ? 'purple' : (greeks.delta > 0.4 ? 'teal' : 'orange')}">${greeks.delta.toFixed(2)}</span> | Gamma <span class="${greeks.gamma > 0.5 ? 'teal' : 'orange'}">${greeks.gamma.toFixed(2)}</span> | Theta <span class="${greeks.theta > -400 ? 'teal' : (greeks.theta > -600 ? 'orange' : 'purple')}">${greeks.theta.toFixed(0)}</span> | Vega <span class="${greeks.vega > 5000 ? 'teal' : (greeks.vega > 3000 ? 'orange' : 'purple')}">${greeks.vega.toFixed(0)}</span> | Price ${greeks.price.toFixed(2)}`;
                document.getElementById('currentGreeks').innerHTML = currentGreeksHtml;
                let edr = parseFloat(document.getElementById('customEdr').value);
                if (isNaN(edr)) {
                    const edrDays = parseInt(document.getElementById('edrDays').value) || 30;
                    edr = sigma * Math.sqrt(edrDays / 365) * 1.96 * 100;
                }
                const tableBody = document.getElementById('positionTable').querySelector('tbody');
                tableBody.innerHTML = '';
                const scenarios = [
                    { label: 'Current', target: greeks.price, class: 'current-row' },
                    { label: 'Breakeven', target: premium, class: '' },
                    { label: '20% Profit', target: premium * 1.2, class: 'profit-row' },
                    { label: 'High Profit (2x)', target: premium * 2, class: 'high-profit-row' }
                ];
                scenarios.forEach(sc => {
                    const spxNeeded = sc.label === 'Current' ? S.toFixed(2) : solveForS(sc.target, S, K, T, r, sigma, q, type, contracts);
                    const scGreeks = blackScholesGreeks(parseFloat(spxNeeded), K, T, r, sigma, q, type);
                    const pl = (scGreeks.price - premium) * contracts * 100;
                    const row = document.createElement('tr');
                    row.classList.add(sc.class);
                    row.innerHTML = `<td>${sc.label} (as of ${expDate})</td><td>${spxNeeded}</td><td>${scGreeks.delta.toFixed(2)}</td><td>${scGreeks.gamma.toFixed(2)}</td><td>${scGreeks.theta.toFixed(0)}</td><td>${scGreeks.vega.toFixed(0)}</td><td>${scGreeks.price.toFixed(2)}</td><td>${pl.toFixed(0)}</td>`;
                    tableBody.appendChild(row);
                });
                const dteBody = document.getElementById('dteTable').querySelector('tbody');
                dteBody.innerHTML = '';
                for (let daysBack = 0; daysBack < 3; daysBack++) {
                    const projT = T - (daysBack / 365);
                    if (projT > 0) {
                        const projGreeks = blackScholesGreeks(S, K, projT, r, sigma, q, type);
                        const notes = projGreeks.theta < -600 ? 'High Theta Burn - Sell if holding' : 'Stable - Monitor IV';
                        const row = document.createElement('tr');
                        row.innerHTML = `<td>${Math.round(projT * 365)}</td><td>${projGreeks.theta.toFixed(0)}</td><td>${projGreeks.vega.toFixed(0)}</td><td>${notes}</td>`;
                        dteBody.appendChild(row);
                    }
                }
                Object.values(charts).forEach(chart => chart?.destroy());
                window.charts = {};
                const spxRange = Array.from({length: 101}, (_, i) => S * (0.9 + i * 0.002));
                const deltas = spxRange.map(s => blackScholesGreeks(s, K, T, r, sigma, q, type).delta);
                const gammas = spxRange.map(s => blackScholesGreeks(s, K, T, r, sigma, q, type).gamma);
                const thetas = spxRange.map(s => blackScholesGreeks(s, K, T, r, sigma, q, type).theta);
                const vegas = spxRange.map(s => blackScholesGreeks(s, K, T, r, sigma, q, type).vega);
                const currentLine = { label: 'Current SPX', data: Array(spxRange.length).fill(null), borderColor: 'gray', borderDash: [5,5], pointRadius: 0 };
                currentLine.data[spxRange.indexOf(spxRange.find(v => v >= S))] = -Infinity;
                const ctxDelta = document.getElementById('deltaChart')?.getContext('2d');
                if (ctxDelta) {
                    charts.delta = new Chart(ctxDelta, {
                        type: 'line',
                        data: {
                            labels: spxRange,
                            datasets: [{
                                label: 'Delta',
                                data: deltas,
                                borderColor: 'blue',
                                fill: false,
                                tension: 0.1
                            }, {
                                label: 'Teal (0.4)',
                                data: Array(spxRange.length).fill(0.4),
                                borderColor: 'teal',
                                borderDash: [5,5],
                                fill: false,
                                pointRadius: 0
                            }, {
                                label: 'Purple (0.6)',
                                data: Array(spxRange.length).fill(0.6),
                                borderColor: 'purple',
                                borderDash: [5,5],
                                fill: false,
                                pointRadius: 0
                            }, currentLine]
                        },
                        options: { responsive: true, scales: { y: { min: 0, max: 1 } }, plugins: { legend: { display: true } } }
                    });
                }
                const ctxGamma = document.getElementById('gammaChart')?.getContext('2d');
                if (ctxGamma) {
                    charts.gamma = new Chart(ctxGamma, {
                        type: 'line',
                        data: {
                            labels: spxRange,
                            datasets: [{
                                label: 'Gamma',
                                data: gammas,
                                borderColor: 'blue',
                                fill: false,
                                tension: 0.1
                            }, {
                                label: 'Teal (0.5)',
                                data: Array(spxRange.length).fill(0.5),
                                borderColor: 'teal',
                                borderDash: [5,5],
                                fill: false,
                                pointRadius: 0
                            }, currentLine]
                        },
                        options: { responsive: true, scales: { y: { suggestedMax: Math.max(...gammas) * 1.2 || 1, beginAtZero: true } }, plugins: { legend: { display: true } } }
                    });
                }
                const ctxTheta = document.getElementById('thetaChart')?.getContext('2d');
                if (ctxTheta) {
                    charts.theta = new Chart(ctxTheta, {
                        type: 'line',
                        data: {
                            labels: spxRange,
                            datasets: [{
                                label: 'Theta',
                                data: thetas,
                                borderColor: 'blue',
                                fill: false,
                                tension: 0.1
                            }, {
                                label: 'Teal (-400)',
                                data: Array(spxRange.length).fill(-400),
                                borderColor: 'teal',
                                borderDash: [5,5],
                                fill: false,
                                pointRadius: 0
                            }, {
                                label: 'Purple (-600)',
                                data: Array(spxRange.length).fill(-600),
                                borderColor: 'purple',
                                borderDash: [5,5],
                                fill: false,
                                pointRadius: 0
                            }, currentLine]
                        },
                        options: { responsive: true, scales: { y: { min: Math.min(...thetas) * 1.2 || -1000, max: 0 } }, plugins: { legend: { display: true } } }
                    });
                }
                const ctxVega = document.getElementById('vegaChart')?.getContext('2d');
                if (ctxVega) {
                    charts.vega = new Chart(ctxVega, {
                        type: 'line',
                        data: {
                            labels: spxRange,
                            datasets: [{
                                label: 'Vega',
                                data: vegas,
                                borderColor: 'blue',
                                fill: false,
                                tension: 0.1
                            }, {
                                label: 'Purple (3000)',
                                data: Array(spxRange.length).fill(3000),
                                borderColor: 'purple',
                                borderDash: [5,5],
                                fill: false,
                                pointRadius: 0
                            }, {
                                label: 'Orange (5000)',
                                data: Array(spxRange.length).fill(5000),
                                borderColor: 'orange',
                                borderDash: [5,5],
                                fill: false,
                                pointRadius: 0
                            }, currentLine]
                        },
                        options: { responsive: true, scales: { y: { beginAtZero: true, suggestedMax: Math.max(...vegas) * 1.2 || 6000 } }, plugins: { legend: { display: true } } }
                    });
                }
            } catch (e) {
                console.log('UPDATE_ALL_ERROR:', e.message, e.stack);
                document.getElementById('chartError').style.display = 'block';
                document.getElementById('chartError').innerText = `UPDATE_ALL_ERROR: ${e.message}. Check console (F12).`;
            }
        }
        function setEdrDays(days) {
            document.getElementById('edrDays').value = days;
            updateAll();
        }
        window.addEventListener('load', () => {
            console.log('JS_INIT: Window loaded');
            const savedKey = localStorage.getItem('apiKey');
            const savedProvider = localStorage.getItem('apiProvider') || 'polygon';
            if (savedKey) {
                document.getElementById('apiKey').value = savedKey;
                document.getElementById('apiProvider').value = savedProvider;
            }
            updateAll(); // Run with defaults
            fetchLiveData(); // Try initial fetch
        });
    </script>
    <p><strong>Notes:</strong> Model uses Black-Scholes (calibrated to match: delta ~98.14, gamma ~0.54, theta ~-391, vega ~5118 at SPX 6541). Fetch chain for contract selection (suggest delta 0.4-0.6). EDR 95% range (override blank for auto). Contango uses front VIX future/spot. Colors color-blind friendly. For short-term: Use DTE forecast for buy/sell timing (e.g., sell on high theta). Not financial advice.</p>
    <div id="finra-disclosure" class="finra-disclosure">
        <h3>Full FINRA Options Disclosure</h3>
        <p>Options trading entails significant risks and is not suitable for all investors. Pursuant to FINRA Rule 2360, investors must be provided with the following disclosures before engaging in options trading:</p>
        <ul>
            <li><strong>High Risk:</strong> Options involve a high degree of risk and may result in the loss of your entire investment or more, especially in uncovered or leveraged strategies. You may be required to deposit additional funds to cover losses.</li>
            <li><strong>Complex Strategies:</strong> Certain complex options strategies, such as spreads, straddles, or uncovered writing, carry additional risks, including limited upside potential and significant downside exposure.</li>
            <li><strong>Time Decay:</strong> Options are time-sensitive instruments. The value of options declines as expiration approaches, potentially resulting in a total loss of the premium paid.</li>
            <li><strong>Market Volatility:</strong> Changes in market volatility can significantly affect options prices, particularly for strategies sensitive to implied volatility (e.g., high vega positions).</li>
            <li><strong>Liquidity Risks:</strong> Some options may have low liquidity, leading to wide bid-ask spreads, difficulty executing trades, or inability to close positions at desired prices.</li>
            <li><strong>Margin Requirements:</strong> Trading options on margin involves additional risks and may require meeting specific financial criteria. Margin calls may necessitate additional funds or liquidation of positions.</li>
            <li><strong>Theoretical Models:</strong> This tool uses the Black-Scholes model for pricing and Greeks calculations, which relies on assumptions (e.g., constant volatility, no transaction costs) that may not reflect actual market conditions. Actual results may differ significantly.</li>
            <li><strong>Regulatory Compliance:</strong> Options trading is subject to FINRA and SEC regulations. Investors must be approved for options trading by their brokerage, which may require a separate options agreement and risk acknowledgment.</li>
            <li><strong>Tax Implications:</strong> Options trading may have complex tax consequences. Consult a tax professional to understand potential impacts.</li>
            <li><strong>Consult Professionals:</strong> Before trading options, consult a qualified financial advisor or broker to ensure options are appropriate for your financial situation, objectives, and risk tolerance.</li>
        </ul>
        <p>For more information, refer to the FINRA Investor Education resources at <a href="https://www.finra.org/investors" target="_blank">www.finra.org/investors</a> or consult the Options Clearing Corporation (OCC) document, <em>Characteristics and Risks of Standardized Options</em>, available at <a href="https://www.theocc.com" target="_blank">www.theocc.com</a>.</p>
        <p><strong>SPX Mastery Disclaimer:</strong> This tool is for educational purposes only. The creator (spxmastery) is not a registered investment advisor and does not provide financial advice. SPX Mastery is not liable for any financial losses or damages resulting from the use of this tool.</p>
    </div>
</body>
</html>
